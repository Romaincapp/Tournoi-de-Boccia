<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionnaire de Tournois de Boccia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --background-color: #f5f5f5;
            --card-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background-color: var(--background-color);
            color: var(--text-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        h1, h2, h3, h4 {
            margin-bottom: 15px;
        }

        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: var(--secondary-color);
        }

        .btn-success {
            background-color: var(--success-color);
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-warning:hover {
            background-color: #e67e22;
        }

        .btn-danger {
            background-color: var(--danger-color);
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 16px;
        }

        .alert {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            color: white;
        }

        .alert-success {
            background-color: var(--success-color);
        }

        .alert-warning {
            background-color: var(--warning-color);
        }

        .alert-danger {
            background-color: var(--danger-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        table, th, td {
            border: 1px solid var(--border-color);
        }

        th, td {
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: var(--primary-color);
            color: white;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .tab-container {
            margin-bottom: 20px;
        }

        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .tab-button {
            padding: 10px 15px;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            margin-right: 5px;
        }

        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .tab-content {
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 0 5px 5px 5px;
            padding: 20px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        .hidden {
            display: none;
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .team-card {
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            width: calc(33.33% - 15px);
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .pool-card {
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .match-card {
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .match-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .match-team {
            flex: 1;
            text-align: center;
        }

        .match-score {
            width: 60px;
            text-align: center;
        }

        .match-vs {
            margin: 0 10px;
            font-weight: bold;
        }

        .bracket {
            display: flex;
            overflow-x: auto;
            padding: 20px 0;
        }

        .bracket-round {
            margin-right: 30px;
            min-width: 200px;
        }

        .bracket-match {
            margin-bottom: 20px;
            padding: 10px;
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .team-card {
                width: calc(50% - 15px);
            }
            
            .flex-container {
                flex-direction: column;
            }
            
            .bracket {
                flex-direction: column;
            }
            
            .bracket-round {
                margin-right: 0;
                margin-bottom: 20px;
            }
        }

        @media (max-width: 480px) {
            .team-card {
                width: 100%;
            }
            
            .tab-buttons {
                flex-direction: column;
            }
            
            .tab-button {
                border-radius: 0;
                margin-right: 0;
                margin-bottom: 5px;
            }
            
            .tab-button:first-child {
                border-radius: 5px 5px 0 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Gestionnaire de Tournois de Boccia</h1>
    </header>

    <div class="container">
        <!-- Wizard de Configuration -->
        <div id="configuration-wizard" class="card">
            <h2>Assistant de Configuration du Tournoi</h2>
            <div id="wizard-step-1">
                <h3>Étape 1 : Informations de Base</h3>
                <div class="form-group">
                    <label for="tournament-name">Nom du Tournoi</label>
                    <input type="text" id="tournament-name" placeholder="Entrez le nom du tournoi">
                </div>
                <div class="form-group">
                    <label for="tournament-date">Date du Tournoi</label>
                    <input type="date" id="tournament-date">
                </div>
                <div class="form-group">
                    <label for="tournament-location">Lieu du Tournoi</label>
                    <input type="text" id="tournament-location" placeholder="Entrez le lieu du tournoi">
                </div>
                <button class="btn" onclick="nextWizardStep(1)">Suivant</button>
            </div>

            <div id="wizard-step-2" class="hidden">
                <h3>Étape 2 : Structure du Tournoi</h3>
                <div class="form-group">
                    <label for="tournament-format">Format du Tournoi</label>
                    <select id="tournament-format">
                        <option value="pools-only">Poules uniquement</option>
                        <option value="knockout-only">Élimination directe uniquement</option>
                        <option value="pools-knockout">Poules suivies d'élimination directe</option>
                    </select>
                </div>
                <div id="pools-config">
                    <div class="form-group">
                        <label for="num-pools">Nombre de Poules</label>
                        <input type="number" id="num-pools" min="1" value="2">
                    </div>
                    <div class="form-group">
                        <label for="teams-per-pool">Équipes par Poule</label>
                        <input type="number" id="teams-per-pool" min="2" value="4">
                    </div>
                    <div class="form-group">
                        <label for="matches-per-team">Nombre de matchs par équipe en qualification</label>
                        <input type="number" id="matches-per-team" min="1" value="3">
                        <small>Définit combien de matchs chaque équipe jouera en phase de poules</small>
                    </div>
                    <div class="form-group">
                        <label for="qualification-mode">Mode de Qualification</label>
                        <select id="qualification-mode">
                            <option value="top-n">Les N meilleures équipes de chaque poule</option>
                            <option value="custom">Personnalisé</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="teams-qualifying">Nombre d'équipes qualifiées par poule</label>
                        <input type="number" id="teams-qualifying" min="1" value="2">
                    </div>
                </div>
                <div id="knockout-config" class="hidden">
                    <div class="form-group">
                        <label for="num-knockout-teams">Nombre d'équipes en phase finale</label>
                        <input type="number" id="num-knockout-teams" min="2" value="8">
                        <small>Doit être une puissance de 2 (2, 4, 8, 16, etc.)</small>
                    </div>
                </div>
                <button class="btn" onclick="prevWizardStep(2)">Précédent</button>
                <button class="btn" onclick="nextWizardStep(2)">Suivant</button>
            </div>

            <div id="wizard-step-3" class="hidden">
                <h3>Étape 3 : Règles de Classement</h3>
                <div class="alert alert-info">
                    <p>Le classement sera effectué selon les critères suivants (par ordre de priorité) :</p>
                    <ol>
                        <li>Total des points (victoire: 3 points, défaite: 1 point, forfait: 0 point)</li>
                        <li>Nombre de matchs gagnés</li>
                        <li>Différence de points (pour - contre)</li>
                        <li>Total des points marqués (points pour)</li>
                    </ol>
                </div>
                <button class="btn" onclick="prevWizardStep(3)">Précédent</button>
                <button class="btn" onclick="finishWizard()">Terminer la Configuration</button>
            </div>
        </div>

        <!-- Interface Principale -->
        <div id="main-interface" class="hidden">
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="showTab('dashboard')">Tableau de Bord</button>
                    <button class="tab-button" onclick="showTab('teams')">Équipes</button>
                    <button class="tab-button" onclick="showTab('pools')">Poules</button>
                    <button class="tab-button" onclick="showTab('matches')">Matchs</button>
                    <button class="tab-button" id="knockout-tab" onclick="showTab('knockout')">Phase Finale</button>
                    <button class="tab-button" onclick="showTab('settings')">Paramètres</button>
                </div>

                <div class="tab-content">
                    <!-- Tableau de Bord -->
                    <div id="dashboard-tab" class="tab-pane active">
                        <h2>Tableau de Bord du Tournoi</h2>
                        <div id="tournament-info" class="card">
                            <h3>Informations du Tournoi</h3>
                            <p><strong>Nom:</strong> <span id="dashboard-tournament-name"></span></p>
                            <p><strong>Date:</strong> <span id="dashboard-tournament-date"></span></p>
                            <p><strong>Lieu:</strong> <span id="dashboard-tournament-location"></span></p>
                            <p><strong>Format:</strong> <span id="dashboard-tournament-format"></span></p>
                        </div>
                        <div id="tournament-status" class="card">
                            <h3>Statut du Tournoi</h3>
                            <p><strong>Équipes inscrites:</strong> <span id="dashboard-teams-count">0</span></p>
                            <p><strong>Poules:</strong> <span id="dashboard-pools-count">0</span></p>
                            <p><strong>Matchs joués:</strong> <span id="dashboard-matches-played">0</span> / <span id="dashboard-total-matches">0</span></p>
                        </div>
                        <div id="quick-actions" class="card">
                            <h3>Actions Rapides</h3>
                            <button class="btn" onclick="showTab('teams')">Gérer les Équipes</button>
                            <button class="btn" onclick="showTab('matches')">Voir les Matchs</button>
                            <button class="btn" onclick="exportTournament()">Exporter le Tournoi</button>
                        </div>
                    </div>

                    <!-- Gestion des Équipes -->
                    <div id="teams-tab" class="tab-pane">
                        <h2>Gestion des Équipes</h2>
                        <div class="card">
                            <h3>Ajouter une Équipe</h3>
                            <div class="form-group">
                                <label for="team-name">Nom de l'Équipe</label>
                                <input type="text" id="team-name" placeholder="Entrez le nom de l'équipe">
                            </div>
                            <div class="form-group">
                                <label for="team-players">Joueurs (optionnel)</label>
                                <textarea id="team-players" placeholder="Entrez les noms des joueurs (un par ligne)"></textarea>
                            </div>
                            <button class="btn" onclick="addTeam()">Ajouter l'Équipe</button>
                        </div>
                        <div class="card">
                            <h3>Équipes Inscrites</h3>
                            <div id="teams-list" class="flex-container">
                                <!-- Les équipes seront ajoutées ici dynamiquement -->
                            </div>
                        </div>
                        <div class="card">
                            <h3>Actions</h3>
                            <button class="btn" onclick="assignTeamsToPools()">Assigner les Équipes aux Poules</button>
                        </div>
                    </div>

                    <!-- Gestion des Poules -->
                    <div id="pools-tab" class="tab-pane">
                        <h2>Gestion des Poules</h2>
                        <div id="pools-container">
                            <!-- Les poules seront ajoutées ici dynamiquement -->
                        </div>
                        <div class="card">
                            <h3>Actions</h3>
                            <button class="btn" onclick="generateMatches()">Générer les Matchs</button>
                        </div>
                    </div>

                    <!-- Gestion des Matchs -->
                    <div id="matches-tab" class="tab-pane">
                        <h2>Gestion des Matchs</h2>
                        <div id="matches-container">
                            <!-- Les matchs seront ajoutés ici dynamiquement -->
                        </div>
                        <div class="card hidden" id="finalize-pools">
                            <h3>Actions</h3>
                            <button class="btn" onclick="finalizePoolStage()">Finaliser les Poules et Créer la Phase Finale</button>
                        </div>
                    </div>

                    <!-- Phase Finale -->
                    <div id="knockout-tab" class="tab-pane">
                        <h2>Phase Finale</h2>
                        <div id="bracket-container" class="bracket">
                            <!-- Le tableau de la phase finale sera ajouté ici dynamiquement -->
                        </div>
                    </div>

                    <!-- Paramètres -->
                    <div id="settings-tab" class="tab-pane">
                        <h2>Paramètres du Tournoi</h2>
                        <div class="card">
                            <h3>Exportation / Importation</h3>
                            <button class="btn" onclick="exportTournament()">Exporter le Tournoi</button>
                            <input type="file" id="import-file" accept=".json" style="display: none;">
                            <button class="btn" onclick="document.getElementById('import-file').click()">Importer un Tournoi</button>
                        </div>
                        <div class="card">
                            <h3>Réinitialisation</h3>
                            <button class="btn btn-danger" onclick="if(confirm('Êtes-vous sûr de vouloir réinitialiser le tournoi ? Toutes les données seront perdues.')) resetTournament()">Réinitialiser le Tournoi</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Modèle de données
        let tournament = {
            info: {
                name: '',
                date: '',
                location: '',
                format: ''
            },
            config: {
                numPools: 2,
                teamsPerPool: 4,
                qualificationMode: 'top-n',
                teamsQualifying: 2,
                numKnockoutTeams: 8
            },
            teams: [],
            pools: [],
            matches: [],
            knockout: {
                rounds: [],
                matches: []
            }
        };

        // Fonctions utilitaires
        function saveToLocalStorage() {
            localStorage.setItem('bocciaTournament', JSON.stringify(tournament));
        }

        function loadFromLocalStorage() {
            const savedTournament = localStorage.getItem('bocciaTournament');
            if (savedTournament) {
                tournament = JSON.parse(savedTournament);
                return true;
            }
            return false;
        }

        function showAlert(message, type = 'success') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(alertDiv, document.querySelector('.container').firstChild);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 3000);
        }

        // Fonctions de l'assistant de configuration
        function nextWizardStep(currentStep) {
            if (currentStep === 1) {
                const name = document.getElementById('tournament-name').value;
                const date = document.getElementById('tournament-date').value;
                const location = document.getElementById('tournament-location').value;
                
                if (!name || !date || !location) {
                    showAlert('Veuillez remplir tous les champs', 'warning');
                    return;
                }
                
                tournament.info.name = name;
                tournament.info.date = date;
                tournament.info.location = location;
                
                document.getElementById('wizard-step-1').classList.add('hidden');
                document.getElementById('wizard-step-2').classList.remove('hidden');
            } else             if (currentStep === 2) {
                const format = document.getElementById('tournament-format').value;
                const numPools = parseInt(document.getElementById('num-pools').value);
                const teamsPerPool = parseInt(document.getElementById('teams-per-pool').value);
                const matchesPerTeam = parseInt(document.getElementById('matches-per-team').value);
                const qualificationMode = document.getElementById('qualification-mode').value;
                const teamsQualifying = parseInt(document.getElementById('teams-qualifying').value);
                const numKnockoutTeams = parseInt(document.getElementById('num-knockout-teams').value);
                
                if (format.includes('pools') && (numPools < 1 || teamsPerPool < 2 || teamsQualifying < 1)) {
                    showAlert('Veuillez entrer des valeurs valides pour les poules', 'warning');
                    return;
                }
                
                if (format.includes('pools') && (matchesPerTeam < 1 || matchesPerTeam > teamsPerPool - 1)) {
                    showAlert(`Le nombre de matchs par équipe doit être entre 1 et ${teamsPerPool - 1}`, 'warning');
                    return;
                }
                
                if (format.includes('knockout') && !isPowerOfTwo(numKnockoutTeams)) {
                    showAlert('Le nombre d\'équipes en phase finale doit être une puissance de 2', 'warning');
                    return;
                }
                
                tournament.info.format = format;
                tournament.config.numPools = numPools;
                tournament.config.teamsPerPool = teamsPerPool;
                tournament.config.matchesPerTeam = matchesPerTeam;
                tournament.config.qualificationMode = qualificationMode;
                tournament.config.teamsQualifying = teamsQualifying;
                tournament.config.numKnockoutTeams = numKnockoutTeams;
                
                document.getElementById('wizard-step-2').classList.add('hidden');
                document.getElementById('wizard-step-3').classList.remove('hidden');
            }
        }

        function prevWizardStep(currentStep) {
            if (currentStep === 2) {
                document.getElementById('wizard-step-2').classList.add('hidden');
                document.getElementById('wizard-step-1').classList.remove('hidden');
            } else if (currentStep === 3) {
                document.getElementById('wizard-step-3').classList.add('hidden');
                document.getElementById('wizard-step-2').classList.remove('hidden');
            }
        }

        function finishWizard() {
            document.getElementById('configuration-wizard').classList.add('hidden');
            document.getElementById('main-interface').classList.remove('hidden');
            
            // Mettre à jour le tableau de bord
            updateDashboard();
            
            // Créer les poules
            createPools();
            
            // Sauvegarder la configuration
            saveToLocalStorage();
        }

        // Gestion des onglets
        function showTab(tabId) {
            // Désactiver tous les onglets
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });
            
            // Activer l'onglet sélectionné
            document.querySelector(`.tab-button[onclick="showTab('${tabId}')"]`).classList.add('active');
            document.getElementById(`${tabId}-tab`).classList.add('active');
        }

        // Mise à jour du tableau de bord
        function updateDashboard() {
            document.getElementById('dashboard-tournament-name').textContent = tournament.info.name;
            document.getElementById('dashboard-tournament-date').textContent = new Date(tournament.info.date).toLocaleDateString();
            document.getElementById('dashboard-tournament-location').textContent = tournament.info.location;
            
            let formatText = '';
            switch (tournament.info.format) {
                case 'pools-only':
                    formatText = 'Poules uniquement';
                    break;
                case 'knockout-only':
                    formatText = 'Élimination directe uniquement';
                    break;
                case 'pools-knockout':
                    formatText = 'Poules suivies d\'élimination directe';
                    break;
                default:
                    formatText = 'Non spécifié';
            }
            
            document.getElementById('dashboard-tournament-format').textContent = formatText;
            document.getElementById('dashboard-teams-count').textContent = tournament.teams.length;
            document.getElementById('dashboard-pools-count').textContent = tournament.pools.length;
            
            const matchesPlayed = tournament.matches.filter(match => match.played).length + 
                                 tournament.knockout.matches.filter(match => match.played).length;
            const totalMatches = tournament.matches.length + tournament.knockout.matches.length;
            
            document.getElementById('dashboard-matches-played').textContent = matchesPlayed;
            document.getElementById('dashboard-total-matches').textContent = totalMatches;
            
            // Masquer l'onglet de phase finale si non applicable
            if (tournament.info.format === 'pools-only') {
                document.getElementById('knockout-tab').style.display = 'none';
            } else {
                document.getElementById('knockout-tab').style.display = 'inline-block';
            }
        }

        // Gestion des équipes
        function addTeam() {
            const teamName = document.getElementById('team-name').value;
            const teamPlayers = document.getElementById('team-players').value;
            
            if (!teamName) {
                showAlert('Veuillez entrer un nom d\'équipe', 'warning');
                return;
            }
            
            // Vérifier si l'équipe existe déjà
            if (tournament.teams.some(team => team.name === teamName)) {
                showAlert('Une équipe avec ce nom existe déjà', 'warning');
                return;
            }
            
            const players = teamPlayers ? teamPlayers.split('\n').filter(p => p.trim()) : [];
            
            const team = {
                id: Date.now().toString(),
                name: teamName,
                players: players,
                pool: null
            };
            
            tournament.teams.push(team);
            saveToLocalStorage();
            
            // Mettre à jour l'affichage
            renderTeams();
            updateDashboard();
            
            // Réinitialiser le formulaire
            document.getElementById('team-name').value = '';
            document.getElementById('team-players').value = '';
            
            showAlert(`L'équipe ${teamName} a été ajoutée avec succès`);
        }

        function renderTeams() {
            const teamsContainer = document.getElementById('teams-list');
            teamsContainer.innerHTML = '';
            
            if (tournament.teams.length === 0) {
                teamsContainer.innerHTML = '<p>Aucune équipe inscrite. Ajoutez des équipes pour commencer.</p>';
                return;
            }
            
            tournament.teams.forEach(team => {
                const teamCard = document.createElement('div');
                teamCard.className = 'team-card';
                teamCard.innerHTML = `
                    <h4>${team.name}</h4>
                    ${team.pool ? `<p><strong>Poule:</strong> ${team.pool}</p>` : ''}
                    ${team.players.length > 0 ? `
                        <p><strong>Joueurs:</strong></p>
                        <ul>
                            ${team.players.map(player => `<li>${player}</li>`).join('')}
                        </ul>
                    ` : '<p><em>Aucun joueur enregistré</em></p>'}
                    <div class="btn-group">
                        <button class="btn btn-warning" onclick="editTeam('${team.id}')">Modifier</button>
                        <button class="btn btn-danger" onclick="deleteTeam('${team.id}')">Supprimer</button>
                    </div>
                `;
                teamsContainer.appendChild(teamCard);
            });
        }

        function editTeam(teamId) {
            const team = tournament.teams.find(t => t.id === teamId);
            
            if (!team) return;
            
            // Créer un formulaire de modification
            const editForm = document.createElement('div');
            editForm.className = 'card';
            editForm.innerHTML = `
                <h3>Modifier Équipe</h3>
                <div class="form-group">
                    <label for="edit-team-name">Nom de l'Équipe</label>
                    <input type="text" id="edit-team-name" value="${team.name}">
                </div>
                <div class="form-group">
                    <label for="edit-team-players">Joueurs (un par ligne)</label>
                    <textarea id="edit-team-players">${team.players.join('\n')}</textarea>
                </div>
                <button class="btn" onclick="saveTeamEdit('${teamId}')">Enregistrer</button>
                <button class="btn btn-danger" onclick="cancelTeamEdit()">Annuler</button>
            `;
            
            // Ajouter le formulaire à la page
            const teamTab = document.getElementById('teams-tab');
            const existingForm = teamTab.querySelector('.edit-form');
            
            if (existingForm) {
                existingForm.remove();
            }
            
            editForm.classList.add('edit-form');
            teamTab.appendChild(editForm);
            
            // Faire défiler jusqu'au formulaire
            editForm.scrollIntoView({ behavior: 'smooth' });
        }

        function saveTeamEdit(teamId) {
            const team = tournament.teams.find(t => t.id === teamId);
            
            if (!team) return;
            
            const newName = document.getElementById('edit-team-name').value;
            const newPlayers = document.getElementById('edit-team-players').value;
            
            if (!newName) {
                showAlert('Le nom de l\'équipe ne peut pas être vide', 'warning');
                return;
            }
            
            // Vérifier si le nouveau nom existe déjà (sauf si c'est le même)
            if (newName !== team.name && tournament.teams.some(t => t.name === newName)) {
                showAlert('Une équipe avec ce nom existe déjà', 'warning');
                return;
            }
            
            team.name = newName;
            team.players = newPlayers ? newPlayers.split('\n').filter(p => p.trim()) : [];
            
            saveToLocalStorage();
            renderTeams();
            document.querySelector('.edit-form').remove();
            
            showAlert('Équipe modifiée avec succès');
        }

        function cancelTeamEdit() {
            document.querySelector('.edit-form').remove();
        }

        function deleteTeam(teamId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette équipe ?')) return;
            
            const teamIndex = tournament.teams.findIndex(t => t.id === teamId);
            
            if (teamIndex === -1) return;
            
            const teamName = tournament.teams[teamIndex].name;
            
            // Supprimer l'équipe des matchs
            tournament.matches = tournament.matches.filter(match => 
                match.team1 !== teamName && match.team2 !== teamName
            );
            
            // Supprimer l'équipe
            tournament.teams.splice(teamIndex, 1);
            
            saveToLocalStorage();
            renderTeams();
            updateDashboard();
            
            showAlert(`L'équipe a été supprimée avec succès`);
        }

        // Gestion des poules
        function createPools() {
            if (tournament.info.format === 'knockout-only') {
                return; // Pas de poules en mode élimination directe uniquement
            }
            
            tournament.pools = [];
            
            for (let i = 1; i <= tournament.config.numPools; i++) {
                tournament.pools.push({
                    id: i,
                    name: `Poule ${i}`,
                    teams: []
                });
            }
            
            renderPools();
        }

        function renderPools() {
            const poolsContainer = document.getElementById('pools-container');
            poolsContainer.innerHTML = '';
            
            if (tournament.pools.length === 0) {
                poolsContainer.innerHTML = '<p>Aucune poule n\'a été créée.</p>';
                return;
            }
            
            tournament.pools.forEach(pool => {
                const poolCard = document.createElement('div');
                poolCard.className = 'pool-card';
                
                let teamsHtml = '';
                if (pool.teams.length === 0) {
                    teamsHtml = '<p><em>Aucune équipe assignée</em></p>';
                } else {
                    // Créer le tableau de classement
                    const standings = calculatePoolStandings(pool.id);
                    
                    teamsHtml = `
                        <table>
                            <thead>
                                <tr>
                                    <th>Pos</th>
                                    <th>Équipe</th>
                                    <th>J</th>
                                    <th>G</th>
                                    <th>P</th>
                                    <th>Pts+</th>
                                    <th>Pts-</th>
                                    <th>Diff</th>
                                    <th>Pts</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${standings.map((team, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>${team.name}</td>
                                        <td>${team.played}</td>
                                        <td>${team.wins}</td>
                                        <td>${team.losses}</td>
                                        <td>${team.pointsFor}</td>
                                        <td>${team.pointsAgainst}</td>
                                        <td>${team.pointsDiff}</td>
                                        <td><strong>${team.points}</strong></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                }
                
                poolCard.innerHTML = `
                    <h3>${pool.name}</h3>
                    ${teamsHtml}
                `;
                
                poolsContainer.appendChild(poolCard);
            });
        }

        function assignTeamsToPools() {
            if (tournament.info.format === 'knockout-only') {
                showAlert('Pas de poules en mode élimination directe', 'warning');
                return;
            }
            
            const totalTeamsNeeded = tournament.config.numPools * tournament.config.teamsPerPool;
            
            if (tournament.teams.length < totalTeamsNeeded) {
                showAlert(`Il manque des équipes. ${totalTeamsNeeded} équipes sont nécessaires, mais seulement ${tournament.teams.length} sont inscrites.`, 'warning');
                return;
            }
            
            // Réinitialiser l'assignation des équipes
            tournament.teams.forEach(team => {
                team.pool = null;
            });
            
            tournament.pools.forEach(pool => {
                pool.teams = [];
            });
            
            // Faire une copie des équipes et les mélanger
            const shuffledTeams = [...tournament.teams].sort(() => Math.random() - 0.5);
            
            // Assigner les équipes aux poules
            for (let i = 0; i < totalTeamsNeeded; i++) {
                const poolIndex = i % tournament.config.numPools;
                const team = shuffledTeams[i];
                
                tournament.pools[poolIndex].teams.push(team.name);
                team.pool = tournament.pools[poolIndex].name;
            }
            
            saveToLocalStorage();
            renderTeams();
            renderPools();
            showAlert('Les équipes ont été assignées aux poules avec succès');
        }

        // Gestion des matchs
        function generateMatches() {
            if (tournament.info.format === 'knockout-only') {
                generateKnockoutMatches(tournament.teams.map(team => team.name));
                showTab('knockout');
                return;
            }
            
            // Vérifier si toutes les poules ont des équipes
            const poolsWithoutTeams = tournament.pools.some(pool => pool.teams.length === 0);
            
            if (poolsWithoutTeams) {
                showAlert('Certaines poules n\'ont pas d\'équipes assignées', 'warning');
                return;
            }
            
            // Réinitialiser les matchs
            tournament.matches = [];
            
            // Générer les matchs pour chaque poule
            tournament.pools.forEach(pool => {
                const teams = pool.teams;
                const matchesPerTeam = tournament.config.matchesPerTeam;
                
                if (matchesPerTeam >= teams.length) {
                    // Si on veut que chaque équipe joue contre toutes les autres
                    for (let i = 0; i < teams.length; i++) {
                        for (let j = i + 1; j < teams.length; j++) {
                            tournament.matches.push({
                                id: Date.now() + Math.random().toString(36).substr(2, 9),
                                pool: pool.id,
                                team1: teams[i],
                                team2: teams[j],
                                score1: null,
                                score2: null,
                                played: false,
                                forfeit: null
                            });
                        }
                    }
                } else {
                    // Si on veut un nombre spécifique de matchs par équipe
                    // On utilise un algorithme pour équilibrer les rencontres
                    
                    // Matrice pour suivre quelles équipes ont déjà joué ensemble
                    const matchMatrix = Array(teams.length).fill().map(() => Array(teams.length).fill(0));
                    // Tableau pour suivre combien de matchs chaque équipe a joué
                    const matchesPlayed = Array(teams.length).fill(0);
                    
                    // Fonction pour vérifier si toutes les équipes ont atteint leur quota de matchs
                    const allTeamsReachedQuota = () => matchesPlayed.every(count => count >= matchesPerTeam);
                    
                    // Continuer à générer des matchs jusqu'à ce que chaque équipe ait joué son quota
                    // ou qu'il ne soit plus possible d'ajouter de matchs
                    let attempts = 0;
                    const maxAttempts = 1000; // Éviter une boucle infinie
                    
                    while (!allTeamsReachedQuota() && attempts < maxAttempts) {
                        attempts++;
                        
                        // Trouver l'équipe qui a joué le moins de matchs
                        let teamIndex = matchesPlayed.indexOf(Math.min(...matchesPlayed));
                        
                        // Si cette équipe a déjà atteint son quota, passer à la suivante
                        if (matchesPlayed[teamIndex] >= matchesPerTeam) {
                            continue;
                        }
                        
                        // Trouver un adversaire pour cette équipe
                        // Préférer les équipes qui ont joué moins de matchs et contre qui elle n'a pas encore joué
                        let opponents = [];
                        
                        for (let i = 0; i < teams.length; i++) {
                            if (i !== teamIndex && matchesPlayed[i] < matchesPerTeam && matchMatrix[teamIndex][i] === 0) {
                                opponents.push({
                                    index: i,
                                    matchesPlayed: matchesPlayed[i]
                                });
                            }
                        }
                        
                        // Trier les adversaires potentiels par nombre de matchs joués
                        opponents.sort((a, b) => a.matchesPlayed - b.matchesPlayed);
                        
                        if (opponents.length > 0) {
                            const opponentIndex = opponents[0].index;
                            
                            // Ajouter le match
                            tournament.matches.push({
                                id: Date.now() + Math.random().toString(36).substr(2, 9),
                                pool: pool.id,
                                team1: teams[teamIndex],
                                team2: teams[opponentIndex],
                                score1: null,
                                score2: null,
                                played: false,
                                forfeit: null
                            });
                            
                            // Mettre à jour la matrice et le compteur
                            matchMatrix[teamIndex][opponentIndex] = 1;
                            matchMatrix[opponentIndex][teamIndex] = 1;
                            matchesPlayed[teamIndex]++;
                            matchesPlayed[opponentIndex]++;
                        } else {
                            // S'il n'y a pas d'adversaire disponible qui n'a pas déjà joué contre cette équipe,
                            // essayer avec des équipes contre lesquelles elle a déjà joué
                            opponents = [];
                            
                            for (let i = 0; i < teams.length; i++) {
                                if (i !== teamIndex && matchesPlayed[i] < matchesPerTeam) {
                                    opponents.push({
                                        index: i,
                                        matchesPlayed: matchesPlayed[i]
                                    });
                                }
                            }
                            
                            opponents.sort((a, b) => a.matchesPlayed - b.matchesPlayed);
                            
                            if (opponents.length > 0) {
                                const opponentIndex = opponents[0].index;
                                
                                // Ajouter le match
                                tournament.matches.push({
                                    id: Date.now() + Math.random().toString(36).substr(2, 9),
                                    pool: pool.id,
                                    team1: teams[teamIndex],
                                    team2: teams[opponentIndex],
                                    score1: null,
                                    score2: null,
                                    played: false,
                                    forfeit: null
                                });
                                
                                matchesPlayed[teamIndex]++;
                                matchesPlayed[opponentIndex]++;
                            }
                        }
                    }
                    
                    // Vérifier si on a réussi à générer suffisamment de matchs
                    if (attempts >= maxAttempts) {
                        showAlert('Impossible de générer exactement ' + matchesPerTeam + ' matchs par équipe. Certaines équipes joueront plus ou moins de matchs.', 'warning');
                    }
                }
            });
            
            saveToLocalStorage();
            renderMatches();
            showTab('matches');
            showAlert('Les matchs ont été générés avec succès');
        }

        function renderMatches() {
            const matchesContainer = document.getElementById('matches-container');
            matchesContainer.innerHTML = '';
            
            if (tournament.matches.length === 0) {
                matchesContainer.innerHTML = '<p>Aucun match n\'a été généré.</p>';
                document.getElementById('finalize-pools').classList.add('hidden');
                return;
            }
            
            // Regrouper les matchs par poule
            const matchesByPool = {};
            
            tournament.matches.forEach(match => {
                if (!matchesByPool[match.pool]) {
                    matchesByPool[match.pool] = [];
                }
                matchesByPool[match.pool].push(match);
            });
            
            // Afficher les matchs par poule
            Object.keys(matchesByPool).forEach(poolId => {
                const poolName = tournament.pools.find(p => p.id == poolId)?.name || `Poule ${poolId}`;
                
                const poolDiv = document.createElement('div');
                poolDiv.className = 'card';
                poolDiv.innerHTML = `<h3>${poolName}</h3>`;
                
                const matchesList = document.createElement('div');
                matchesList.className = 'matches-list';
                
                matchesByPool[poolId].forEach(match => {
                    const matchCard = document.createElement('div');
                    matchCard.className = 'match-card';
                    
                    let statusClass = match.played ? 'match-played' : 'match-pending';
                    if (match.forfeit) statusClass = 'match-forfeit';
                    
                    matchCard.innerHTML = `
                        <div class="match-result ${statusClass}">
                            <div class="match-team">
                                <span>${match.team1}</span>
                            </div>
                            
                            <input type="number" class="match-score" id="score1-${match.id}" 
                                value="${match.score1 !== null ? match.score1 : ''}" 
                                ${match.played ? '' : 'placeholder="..."'}>
                            
                            <div class="match-vs">VS</div>
                            
                            <input type="number" class="match-score" id="score2-${match.id}" 
                                value="${match.score2 !== null ? match.score2 : ''}" 
                                ${match.played ? '' : 'placeholder="..."'}>
                            
                            <div class="match-team">
                                <span>${match.team2}</span>
                            </div>
                        </div>
                        
                        <div class="match-actions">
                            ${!match.played ? 
                                `<button class="btn btn-success" onclick="saveMatchResult('${match.id}')">Enregistrer</button>
                                <button class="btn btn-warning" onclick="setMatchForfeit('${match.id}')">Forfait</button>` :
                                `<button class="btn" onclick="editMatchResult('${match.id}')">Modifier</button>`
                            }
                        </div>
                    `;
                    
                    matchesList.appendChild(matchCard);
                });
                
                poolDiv.appendChild(matchesList);
                matchesContainer.appendChild(poolDiv);
            });
            
            // Afficher le bouton de finalisation si tous les matchs sont joués
            const allMatchesPlayed = tournament.matches.every(match => match.played);
            document.getElementById('finalize-pools').classList.toggle('hidden', !allMatchesPlayed || tournament.info.format === 'pools-only');
        }

        function saveMatchResult(matchId) {
            const match = tournament.matches.find(m => m.id === matchId);
            
            if (!match) return;
            
            const score1 = parseInt(document.getElementById(`score1-${matchId}`).value);
            const score2 = parseInt(document.getElementById(`score2-${matchId}`).value);
            
            if (isNaN(score1) || isNaN(score2) || score1 < 0 || score2 < 0) {
                showAlert('Veuillez entrer des scores valides', 'warning');
                return;
            }
            
            match.score1 = score1;
            match.score2 = score2;
            match.played = true;
            match.forfeit = null;
            
            saveToLocalStorage();
            renderMatches();
            renderPools();
            updateDashboard();
            
            showAlert('Le résultat du match a été enregistré avec succès');
        }

        function editMatchResult(matchId) {
            const match = tournament.matches.find(m => m.id === matchId);
            
            if (!match) return;
            
            match.played = false;
            
            saveToLocalStorage();
            renderMatches();
            renderPools();
            updateDashboard();
        }

        function setMatchForfeit(matchId) {
            const match = tournament.matches.find(m => m.id === matchId);
            
            if (!match) return;
            
            const team = prompt(`Quelle équipe déclare forfait?\n1: ${match.team1}\n2: ${match.team2}`);
            
            if (team !== '1' && team !== '2') {
                showAlert('Veuillez entrer 1 ou 2', 'warning');
                return;
            }
            
            match.forfeit = team;
            match.played = true;
            
            if (team === '1') {
                match.score1 = 0;
                match.score2 = 20; // Score arbitraire pour le vainqueur par forfait
            } else {
                match.score1 = 20; // Score arbitraire pour le vainqueur par forfait
                match.score2 = 0;
            }
            
            saveToLocalStorage();
            renderMatches();
            renderPools();
            updateDashboard();
            
            showAlert(`Forfait enregistré pour ${team === '1' ? match.team1 : match.team2}`);
        }

        // Calcul des classements
        function calculatePoolStandings(poolId) {
            const pool = tournament.pools.find(p => p.id === poolId);
            
            if (!pool) return [];
            
            // Initialiser les statistiques de chaque équipe
            const standings = pool.teams.map(teamName => {
                return {
                    name: teamName,
                    played: 0,
                    wins: 0,
                    losses: 0,
                    pointsFor: 0,
                    pointsAgainst: 0,
                    pointsDiff: 0,
                    points: 0
                };
            });
            
            // Calculer les statistiques à partir des matchs
            tournament.matches
                .filter(match => match.pool === poolId && match.played)
                .forEach(match => {
                    // Trouver les équipes dans le classement
                    const team1 = standings.find(team => team.name === match.team1);
                    const team2 = standings.find(team => team.name === match.team2);
                    
                    if (!team1 || !team2) return;
                    
                    // Mettre à jour les statistiques
                    team1.played++;
                    team2.played++;
                    
                    team1.pointsFor += match.score1;
                    team1.pointsAgainst += match.score2;
                    team2.pointsFor += match.score2;
                    team2.pointsAgainst += match.score1;
                    
                    // Déterminer le gagnant
                    if (match.forfeit) {
                        // En cas de forfait
                        if (match.forfeit === '1') {
                            team2.wins++;
                            team1.losses++;
                            team2.points += 3; // Victoire
                            team1.points += 0; // Forfait
                        } else {
                            team1.wins++;
                            team2.losses++;
                            team1.points += 3; // Victoire
                            team2.points += 0; // Forfait
                        }
                    } else {
                        // Match normal
                        if (match.score1 > match.score2) {
                            team1.wins++;
                            team2.losses++;
                            team1.points += 3; // Victoire
                            team2.points += 1; // Défaite
                        } else if (match.score1 < match.score2) {
                            team2.wins++;
                            team1.losses++;
                            team2.points += 3; // Victoire
                            team1.points += 1; // Défaite
                        } else {
                            // En cas d'égalité (ne devrait pas arriver en boccia)
                            team1.points += 2;
                            team2.points += 2;
                        }
                    }
                });
            
            // Calculer la différence de points
            standings.forEach(team => {
                team.pointsDiff = team.pointsFor - team.pointsAgainst;
            });
            
            // Trier selon les critères de classement
            standings.sort((a, b) => {
                // 1. Total des points
                if (b.points !== a.points) return b.points - a.points;
                
                // 2. Nombre de matchs gagnés
                if (b.wins !== a.wins) return b.wins - a.wins;
                
                // 3. Différence de points
                if (b.pointsDiff !== a.pointsDiff) return b.pointsDiff - a.pointsDiff;
                
                // 4. Total des points marqués
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                
                // 5. Par ordre alphabétique si tout est égal
                return a.name.localeCompare(b.name);
            });
            
            return standings;
        }

        // Phase finale
        function finalizePoolStage() {
            if (tournament.info.format !== 'pools-knockout') {
                return;
            }
            
            // Vérifier si tous les matchs des poules sont joués
            const allMatchesPlayed = tournament.matches.every(match => match.played);
            
            if (!allMatchesPlayed) {
                showAlert('Tous les matchs des poules doivent être joués', 'warning');
                return;
            }
            
            // Déterminer les équipes qualifiées
            const qualifiedTeams = [];
            
            tournament.pools.forEach(pool => {
                const standings = calculatePoolStandings(pool.id);
                const numTeamsToQualify = tournament.config.teamsQualifying;
                
                // Ajouter les équipes qualifiées
                for (let i = 0; i < Math.min(numTeamsToQualify, standings.length); i++) {
                    qualifiedTeams.push({
                        name: standings[i].name,
                        pool: pool.id,
                        rank: i + 1
                    });
                }
            });
            
            // Vérifier si le nombre d'équipes est une puissance de 2
            if (!isPowerOfTwo(qualifiedTeams.length)) {
                showAlert(`Le nombre d'équipes qualifiées (${qualifiedTeams.length}) n'est pas une puissance de 2. Ajustez la configuration.`, 'warning');
                return;
            }
            
            // Trier les équipes pour les appariements
            sortTeamsForKnockout(qualifiedTeams);
            
            // Générer les matchs de la phase finale
            generateKnockoutMatches(qualifiedTeams.map(team => team.name));
            
            saveToLocalStorage();
            showTab('knockout');
            showAlert('Phase finale créée avec succès');
        }

        function sortTeamsForKnockout(teams) {
            // Cette fonction organise les équipes pour la phase à élimination directe
            // afin que les meilleures équipes ne se rencontrent pas trop tôt
            
            // Par exemple, pour 8 équipes, l'ordre serait: 1, 8, 4, 5, 2, 7, 3, 6
            // où les nombres représentent le classement (1 = meilleur)
            
            // Pour l'instant, nous utilisons un tri simple basé sur le classement et la poule
            teams.sort((a, b) => {
                if (a.rank !== b.rank) return a.rank - b.rank;
                return a.pool - b.pool;
            });
            
            return teams;
        }

        function generateKnockoutMatches(teams) {
            // Réinitialiser la phase finale
            tournament.knockout = {
                rounds: [],
                matches: []
            };
            
            // Déterminer le nombre de tours
            const numTeams = teams.length;
            const numRounds = Math.log2(numTeams);
            
            // Créer les tours
            for (let i = 0; i < numRounds; i++) {
                const roundName = i === numRounds - 1 ? 'Finale' : 
                                 i === numRounds - 2 ? 'Demi-finales' :
                                 i === numRounds - 3 ? 'Quarts de finale' :
                                 `Tour ${numRounds - i}`;
                
                tournament.knockout.rounds.push({
                    id: i + 1,
                    name: roundName,
                    numMatches: Math.pow(2, numRounds - i - 1)
                });
            }
            
            // Créer les matchs du premier tour
            const firstRound = tournament.knockout.rounds[0];
            
            for (let i = 0; i < firstRound.numMatches; i++) {
                const matchId = Date.now() + Math.random().toString(36).substr(2, 9);
                
                tournament.knockout.matches.push({
                    id: matchId,
                    round: firstRound.id,
                    match: i + 1,
                    team1: i < teams.length / 2 ? teams[i] : null,
                    team2: i < teams.length / 2 ? teams[teams.length - 1 - i] : null,
                    score1: null,
                    score2: null,
                    played: false,
                    nextMatchId: null
                });
            }
            
            // Créer les matchs des tours suivants (vides)
            for (let r = 1; r < tournament.knockout.rounds.length; r++) {
                const round = tournament.knockout.rounds[r];
                const prevRound = tournament.knockout.rounds[r - 1];
                
                for (let i = 0; i < round.numMatches; i++) {
                    const matchId = Date.now() + Math.random().toString(36).substr(2, 9) + r + i;
                    
                    // Trouver les matchs précédents qui alimentent ce match
                    const prevMatch1 = tournament.knockout.matches.find(m => 
                        m.round === prevRound.id && m.match === i * 2 + 1
                    );
                    
                    const prevMatch2 = tournament.knockout.matches.find(m => 
                        m.round === prevRound.id && m.match === i * 2 + 2
                    );
                    
                    // Mettre à jour les ID des matchs suivants
                    if (prevMatch1) prevMatch1.nextMatchId = matchId;
                    if (prevMatch2) prevMatch2.nextMatchId = matchId;
                    
                    tournament.knockout.matches.push({
                        id: matchId,
                        round: round.id,
                        match: i + 1,
                        team1: null,
                        team2: null,
                        score1: null,
                        score2: null,
                        played: false,
                        nextMatchId: null
                    });
                }
            }
            
            renderKnockoutBracket();
        }

        function renderKnockoutBracket() {
            const bracketContainer = document.getElementById('bracket-container');
            bracketContainer.innerHTML = '';
            
            if (tournament.knockout.rounds.length === 0) {
                bracketContainer.innerHTML = '<p>La phase finale n\'a pas encore été générée.</p>';
                return;
            }
            
            // Créer un conteneur pour chaque tour
            tournament.knockout.rounds.forEach(round => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round';
                roundDiv.innerHTML = `<h3>${round.name}</h3>`;
                
                // Trouver les matchs de ce tour
                const roundMatches = tournament.knockout.matches
                    .filter(match => match.round === round.id)
                    .sort((a, b) => a.match - b.match);
                
                // Créer les matchs
                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'bracket-match';
                    
                    let team1 = match.team1 ? match.team1 : 'À déterminer';
                    let team2 = match.team2 ? match.team2 : 'À déterminer';
                    
                    let statusClass = match.played ? 'match-played' : 'match-pending';
                    
                    matchDiv.innerHTML = `
                        <div class="match-result ${statusClass}">
                            <div class="match-team">
                                <span>${team1}</span>
                            </div>
                            
                            <input type="number" class="match-score" id="ko-score1-${match.id}" 
                                value="${match.score1 !== null ? match.score1 : ''}" 
                                ${match.played ? '' : 'placeholder="..."'}
                                ${(!match.team1 || !match.team2) ? 'disabled' : ''}>
                            
                            <div class="match-vs">VS</div>
                            
                            <input type="number" class="match-score" id="ko-score2-${match.id}" 
                                value="${match.score2 !== null ? match.score2 : ''}" 
                                ${match.played ? '' : 'placeholder="..."'}
                                ${(!match.team1 || !match.team2) ? 'disabled' : ''}>
                            
                            <div class="match-team">
                                <span>${team2}</span>
                            </div>
                        </div>
                        
                        ${(match.team1 && match.team2) ? 
                            `<div class="match-actions">
                                ${!match.played ? 
                                    `<button class="btn btn-success" onclick="saveKnockoutResult('${match.id}')">Enregistrer</button>` :
                                    `<button class="btn" onclick="editKnockoutResult('${match.id}')">Modifier</button>`
                                }
                            </div>` : 
                            ''
                        }
                    `;
                    
                    roundDiv.appendChild(matchDiv);
                });
                
                bracketContainer.appendChild(roundDiv);
            });
        }

        function saveKnockoutResult(matchId) {
            const match = tournament.knockout.matches.find(m => m.id === matchId);
            
            if (!match || !match.team1 || !match.team2) return;
            
            const score1 = parseInt(document.getElementById(`ko-score1-${matchId}`).value);
            const score2 = parseInt(document.getElementById(`ko-score2-${matchId}`).value);
            
            if (isNaN(score1) || isNaN(score2) || score1 < 0 || score2 < 0) {
                showAlert('Veuillez entrer des scores valides', 'warning');
                return;
            }
            
            // En boccia, on n'accepte pas les égalités en phase finale
            if (score1 === score2) {
                showAlert('Le match ne peut pas se terminer par une égalité en phase finale', 'warning');
                return;
            }
            
            match.score1 = score1;
            match.score2 = score2;
            match.played = true;
            
            // Déterminer le vainqueur
            const winner = score1 > score2 ? match.team1 : match.team2;
            
            // Mettre à jour le prochain match si applicable
            if (match.nextMatchId) {
                const nextMatch = tournament.knockout.matches.find(m => m.id === match.nextMatchId);
                
                if (nextMatch) {
                    // Trouver l'autre match qui alimente le prochain match
                    const otherMatch = tournament.knockout.matches.find(m => 
                        m.nextMatchId === match.nextMatchId && m.id !== match.id
                    );
                    
                    // Déterminer si le gagnant va en team1 ou team2 du prochain match
                    if (otherMatch && otherMatch.match % 2 === 0 && match.match % 2 === 1) {
                        nextMatch.team1 = winner;
                    } else if (otherMatch && otherMatch.match % 2 === 1 && match.match % 2 === 0) {
                        nextMatch.team2 = winner;
                    } else {
                        // Si l'autre match n'existe pas encore ou cas particulier
                        if (!nextMatch.team1) {
                            nextMatch.team1 = winner;
                        } else {
                            nextMatch.team2 = winner;
                        }
                    }
                }
            }
            
            saveToLocalStorage();
            renderKnockoutBracket();
            updateDashboard();
            
            showAlert('Le résultat du match a été enregistré avec succès');
        }

        function editKnockoutResult(matchId) {
            const match = tournament.knockout.matches.find(m => m.id === matchId);
            
            if (!match) return;
            
            // Vérifier si des matchs ultérieurs ont été joués
            const subsequentMatchesPlayed = hasSubsequentMatchesPlayed(match);
            
            if (subsequentMatchesPlayed) {
                showAlert('Impossible de modifier ce match car des matchs ultérieurs ont déjà été joués', 'warning');
                return;
            }
            
            match.played = false;
            match.score1 = null;
            match.score2 = null;
            
            // Réinitialiser les équipes dans les matchs suivants
            if (match.nextMatchId) {
                const nextMatch = tournament.knockout.matches.find(m => m.id === match.nextMatchId);
                
                if (nextMatch) {
                    // Déterminer quelle équipe réinitialiser
                    const otherMatch = tournament.knockout.matches.find(m => 
                        m.nextMatchId === match.nextMatchId && m.id !== match.id
                    );
                    
                    if (otherMatch && otherMatch.played) {
                        // Si l'autre match a été joué, déterminer quel côté réinitialiser
                        if (otherMatch.match % 2 === 0 && match.match % 2 === 1) {
                            nextMatch.team1 = null;
                        } else if (otherMatch.match % 2 === 1 && match.match % 2 === 0) {
                            nextMatch.team2 = null;
                        }
                    } else {
                        // Si l'autre match n'a pas été joué, réinitialiser les deux côtés
                        nextMatch.team1 = null;
                        nextMatch.team2 = null;
                    }
                }
            }
            
            saveToLocalStorage();
            renderKnockoutBracket();
            updateDashboard();
        }

        function hasSubsequentMatchesPlayed(match) {
            if (!match.nextMatchId) return false;
            
            const nextMatch = tournament.knockout.matches.find(m => m.id === match.nextMatchId);
            
            if (!nextMatch) return false;
            
            return nextMatch.played || hasSubsequentMatchesPlayed(nextMatch);
        }

        // Exportation et importation
        function exportTournament() {
            const dataStr = JSON.stringify(tournament, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const exportFileName = tournament.info.name ?
                `${tournament.info.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json` :
                `tournoi_boccia_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileName);
            linkElement.click();
            
            showAlert('Tournoi exporté avec succès');
        }

        // Importer une liste d'équipes
        function importTeamsList() {
            const fileInput = document.getElementById('teams-import-file');
            const file = fileInput.files[0];
            
            if (!file) {
                showAlert('Veuillez sélectionner un fichier', 'warning');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const content = e.target.result;
                const lines = content.split(/\r?\n/);
                
                let importCount = 0;
                let skippedCount = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const teamName = lines[i].trim();
                    
                    if (!teamName) continue; // Ignorer les lignes vides
                    
                    // Vérifier si l'équipe existe déjà
                    if (tournament.teams.some(team => team.name === teamName)) {
                        skippedCount++;
                        continue;
                    }
                    
                    const team = {
                        id: Date.now().toString() + i,
                        name: teamName,
                        players: [],
                        pool: null
                    };
                    
                    tournament.teams.push(team);
                    importCount++;
                }
                
                if (importCount > 0) {
                    saveToLocalStorage();
                    renderTeams();
                    updateDashboard();
                    
                    showAlert(`${importCount} équipe(s) importée(s) avec succès${skippedCount > 0 ? `, ${skippedCount} équipe(s) ignorée(s) (déjà présentes)` : ''}`);
                } else {
                    showAlert('Aucune équipe n\'a été importée', 'warning');
                }
                
                // Réinitialiser le champ de fichier
                fileInput.value = '';
            };
            
            reader.readAsText(file);
        }
        
        // Fonctions utilitaires supplémentaires
        function isPowerOfTwo(n) {
            return n && (n & (n - 1)) === 0;
        }

        function resetTournament() {
            tournament = {
                info: {
                    name: '',
                    date: '',
                    location: '',
                    format: ''
                },
                config: {
                    numPools: 2,
                    teamsPerPool: 4,
                    matchesPerTeam: 3,
                    qualificationMode: 'top-n',
                    teamsQualifying: 2,
                    numKnockoutTeams: 8
                },
                teams: [],
                pools: [],
                matches: [],
                knockout: {
                    rounds: [],
                    matches: []
                }
            };
            
            saveToLocalStorage();
            
            // Afficher l'assistant de configuration
            document.getElementById('configuration-wizard').classList.remove('hidden');
            document.getElementById('main-interface').classList.add('hidden');
            
            // Réinitialiser les étapes du wizard
            document.getElementById('wizard-step-1').classList.remove('hidden');
            document.getElementById('wizard-step-2').classList.add('hidden');
            document.getElementById('wizard-step-3').classList.add('hidden');
            
            // Réinitialiser les champs du formulaire
            document.getElementById('tournament-name').value = '';
            document.getElementById('tournament-date').value = '';
            document.getElementById('tournament-location').value = '';
            
            showAlert('Tournoi réinitialisé avec succès');
        }

        // Gestion des événements
        document.getElementById('tournament-format').addEventListener('change', function() {
            const format = this.value;
            
            document.getElementById('pools-config').classList.toggle('hidden', format === 'knockout-only');
            document.getElementById('knockout-config').classList.toggle('hidden', format === 'pools-only');
        });

        document.getElementById('import-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importedTournament = JSON.parse(e.target.result);
                    
                    // Validation basique
                    if (!importedTournament.info || !importedTournament.config) {
                        throw new Error('Format de fichier invalide');
                    }
                    
                    tournament = importedTournament;
                    saveToLocalStorage();
                    
                    // Afficher l'interface principale
                    document.getElementById('configuration-wizard').classList.add('hidden');
                    document.getElementById('main-interface').classList.remove('hidden');
                    
                    // Mettre à jour l'interface
                    updateDashboard();
                    renderTeams();
                    renderPools();
                    renderMatches();
                    renderKnockoutBracket();
                    
                    showAlert('Tournoi importé avec succès');
                } catch (error) {
                    showAlert(`Erreur lors de l'importation: ${error.message}`, 'danger');
                }
            };
            
            reader.readAsText(file);
        });

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            // Vérifier s'il y a un tournoi sauvegardé
            if (loadFromLocalStorage()) {
                // Afficher l'interface principale
                document.getElementById('configuration-wizard').classList.add('hidden');
                document.getElementById('main-interface').classList.remove('hidden');
                
                // Mettre à jour l'interface
                updateDashboard();
                renderTeams();
                renderPools();
                renderMatches();
                renderKnockoutBracket();
                
                showAlert('Tournoi chargé depuis le stockage local');
            }
        });
    </script>
</body>
</html>
